"use strict";(self.webpackChunkpolyproto_docs=self.webpackChunkpolyproto_docs||[]).push([[9483],{3615:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"protocols/auth","title":"polyproto-auth Extension Specification","description":"Namespace: auth","source":"@site/docs/protocols/auth.md","sourceDirName":"protocols","slug":"/protocols/auth","permalink":"/docs/protocols/auth","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"polyproto Core Protocol Specification","permalink":"/docs/protocols/core"},"next":{"title":"polyproto-chat Extension Specification","permalink":"/docs/protocols/chat"}}');var s=t(4848),o=t(8453);const r={},a="polyproto-auth Extension Specification",c={},h=[{value:"1. Registration of a new actor",id:"1-registration-of-a-new-actor",level:2},{value:"1.1 Registering a new actor on a polyproto home server",id:"11-registering-a-new-actor-on-a-polyproto-home-server",level:2},{value:"1.2 Authenticating a new client on a polyproto home server",id:"12-authenticating-a-new-client-on-a-polyproto-home-server",level:2},{value:"1.3 Authenticating on a foreign server",id:"13-authenticating-on-a-foreign-server",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",mermaid:"mermaid",p:"p",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"polyproto-auth-extension-specification",children:"polyproto-auth Extension Specification"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Namespace:"})," ",(0,s.jsx)(n.code,{children:"auth"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Version:"})," ",(0,s.jsx)(n.code,{children:"v1.0-alpha.1"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Base Path:"})," ",(0,s.jsx)(n.code,{children:"/.p2/auth/v1/"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"v1.0.0-alpha.1"})," - Treat this as an unfinished draft.\n",(0,s.jsx)(n.a,{href:"https://semver.org/spec/v2.0.0.html",children:"Semantic versioning v2.0.0"})," is used to version this specification.\nThe version number specified here also applies to the API documentation."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"polyproto-auth"})," extension is a protocol extension for polyproto that provides a basic\nauthentication mechanism to register new users and authenticate existing users."]}),"\n",(0,s.jsx)(n.h2,{id:"1-registration-of-a-new-actor",children:"1. Registration of a new actor"}),"\n",(0,s.jsx)(n.p,{children:'Registering a new actor in the context of polyproto is done through an API route defined in the\npolyproto-auth\n["No registration needed" API](/APIs/Core/Routes%3A No registration needed/#post-create-identity)\ndocumentation.'}),"\n",(0,s.jsx)(n.h2,{id:"11-registering-a-new-actor-on-a-polyproto-home-server",children:"1.1 Registering a new actor on a polyproto home server"}),"\n",(0,s.jsxs)(n.p,{children:["To register, the client sends the necessary information to their home server. The server verifies\nthe data, checks username availability, and responds with HTTP 201 and the new identity's federation\nID, if successful. However, a session token is not provided until the actor authenticates a client,\nas detailed in section ",(0,s.jsx)(n.a,{href:"#12-authenticating-a-new-client-on-a-polyproto-home-server",children:"1.2"}),"."]}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\nautonumber\n\nactor c as Client\nparticipant s as Server\n\nc->>s: Registration information\ns->>s: Verify correctness of provided information,<br />check if username is available, etc\n\nalt verification successful\n  s->>s: Verify provided CSR\n\n  alt CSR okay\n    s->>s: Sign CSR\n    s->>c: HTTP status code 201, with actor federation ID\n  end\nend"}),"\n",(0,s.jsx)(n.p,{children:"Fig. 1: Sequence diagram of a successful identity creation process."}),"\n",(0,s.jsx)(n.h2,{id:"12-authenticating-a-new-client-on-a-polyproto-home-server",children:"1.2 Authenticating a new client on a polyproto home server"}),"\n",(0,s.jsxs)(n.p,{children:["To access their account from a new device, an actor authenticates the session with their home server\nby sending authentication information and a\n",(0,s.jsx)(n.a,{href:"./core.md/#61-home-server-signed-certificates-for-public-client-identity-keys-id-cert",children:"certificate signing request (CSR)"}),"\nfor the new client. If verified successfully, the server signs the CSR and responds with the newly\ngenerated ID-Cert and a session token corresponding to this ID-Cert."]}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\nautonumber\n\nactor c as Client\nparticipant s as Server\n\nc->>s: Auth information, CSR\ns->>s: Verify correctness of provided auth information\n\nalt Verified successfully\n  s->>s: Verify provided CSR\n  alt CSR okay\n  s->>s: Sign CSR\n  s->>c: HTTP status code 201, ID-Cert + session token\n  end\nend\n"}),"\n",(0,s.jsx)(n.p,{children:"Fig. 2: Sequence diagram of a successful client authentication process."}),"\n",(0,s.jsx)(n.p,{children:"The client is now authenticated and can use the session token and ID-Cert to perform actions on\nbehalf of the actor identified by the ID-Cert."}),"\n",(0,s.jsx)(n.h2,{id:"13-authenticating-on-a-foreign-server",children:"1.3 Authenticating on a foreign server"}),"\n",(0,s.jsx)(n.p,{children:"Authenticating on a foreign server requires the actor to sign a challenge string with their private\nidentity key and send it, along with their ID-Cert, to the server. The server then validates the\nID-Cert's origin, the challenge string's signature, and the ID-Cert's validity."}),"\n",(0,s.jsx)(n.p,{children:"If the verification is successful, the foreign server can issue a session token to the actor."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example:"}),"\nSay that Alice is on server A, and wants to authenticate on Server B, using her existing identity."]}),"\n",(0,s.jsx)(n.p,{children:"Alice's client sends a request to Server B for a challenge string, telling Server B the session ID\nthey are communicating from in the process. Upon receiving a response, Alice signs this challenge\nstring with the correct private key. They then send the signature to Server B. Server B can now\nverify that it was actually Alice who signed the string, and not a malicious outsider. Server B does\nthis by requesting Alice's ID-Cert, specifically the ID-Cert matching the session ID Alice\nidentified with to Server B. If all goes well, server B will send a newly generated session token\nback to Alice's client. Alice's client can then authenticate with server B by using this token."}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\nautonumber\n\nactor a as Alice\nparticipant sb as Server B\nparticipant sa as Server A\n\na->>sb: Challenge string request including current Session ID\nsb->>a: Challenge string\na->>sb: Signed challenge, ID-Cert, optional payload\nsb->>sa: Get Server A Public Certificate\nsa->>sb: Send Public Certificate\nsb->>sb: Verify signature of challenge string\nsb->>a: Session token, optional payload"}),"\n",(0,s.jsx)(n.p,{children:"Fig. 3: Sequence diagram of a successful identity verification."}),"\n",(0,s.jsx)(n.p,{children:"In the diagram, Alice's \"optional payload\" is extra data that might be requested by servers.\nThis is useful when using a single identity across various polyproto implementations, due to\ndiffering information needs. The payload is signed with the actor's private identity key."}),"\n",(0,s.jsx)(n.p,{children:'Likewise, the "optional payload" sent by the server in the above diagram can be used by\nimplementations to send additional information to the client. An example might be initial account\ninformation.'}),"\n",(0,s.jsxs)(n.admonition,{title:"Example",type:"tip",children:[(0,s.jsxs)(n.p,{children:['Alice currently has a polyproto identity, which she created when signing up for\n"',(0,s.jsx)(n.a,{href:"https://example.com/chat",children:"https://example.com/chat"}),'". When signing up for this service, she didn\'t need to provide any\nadditional information on registration. However, when she wants to actor her existing identity\nto sign up for "',(0,s.jsx)(n.a,{href:"https://example.com/social",children:"https://example.com/social"}),'", she is asked to provide her email address, which\nshe can provide as the "optional payload". The server can then store the email address in its\'\ndatabase, associate it with Alice\'s identity, and let Alice log in with her existing identity.']}),(0,s.jsxs)(n.p,{children:["If Alice's session token expires, they can repeat this process of requesting a challenge string and,\ntogether with her ID-Cert, exchange it for a session token. However, if Alice wants to access this\nthird party account from a completely new device, they will have to perform the steps described in\nsection ",(0,s.jsx)(n.a,{href:"#12-authenticating-a-new-client-on-a-polyproto-home-server",children:"1.2"})," to obtain a valid\nID-Cert for that session."]}),(0,s.jsx)(n.hr,{})]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);