"use strict";(self.webpackChunkpolyproto_docs=self.webpackChunkpolyproto_docs||[]).push([[3054],{3353:e=>{e.exports=JSON.parse('{"permalink":"/blog/2023/11/23/webassembly-chorus","source":"@site/blog/2023-11-23-webassembly-chorus.md","title":"Porting chorus to WebAssembly + Client Update","description":"What the current state of GUI libraries in Rust means for Polyphony and chorus, and why we are porting chorus to WebAssembly.","date":"2023-11-23T00:00:00.000Z","tags":[],"readingTime":1.855,"hasTruncateMarker":true,"authors":[{"name":"bitfl0wer","description":"Lead silly individual","avatar":"https://avatars.githubusercontent.com/u/39242991?v=4","key":"bitfl0wer","page":null}],"frontMatter":{"draft":false,"date":"2023-11-23T00:00:00.000Z","categories":["chorus","polyphony","updates"],"authors":["bitfl0wer"]},"unlisted":false,"prevItem":{"title":"Account migration in polyproto","permalink":"/blog/2024/02/07/account-migration"},"nextItem":{"title":"Getting started with the Polyphony Client","permalink":"/blog/2023/09/02/client-getting-started"}}')},4786:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var o=n(3353),s=n(4848),r=n(8453);const i={draft:!1,date:new Date("2023-11-23T00:00:00.000Z"),categories:["chorus","polyphony","updates"],authors:["bitfl0wer"]},a="Porting chorus to WebAssembly + Client Update",l={authorsImageUrls:[void 0]},h=[];function c(e){const t={code:"code",em:"em",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"What the current state of GUI libraries in Rust means for Polyphony and chorus, and why we are porting chorus to WebAssembly."}),"\n","\n",(0,s.jsx)(t.p,{children:"Hi all!"}),"\n",(0,s.jsxs)(t.p,{children:["To make this part of the post short: The web-based client will be worked on ",(0,s.jsx)(t.em,{children:"before"})," the native one, if there even ever will be one. The reason is that no currently available native Rust GUI library meets the standards I'd like to see when using it to build an application I am putting my name behind. I'd like to have"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"accessibility"}),"\n",(0,s.jsx)(t.li,{children:"great styling"}),"\n",(0,s.jsx)(t.li,{children:"cross compilation"}),"\n",(0,s.jsx)(t.li,{children:"memory safety"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'and the current state of Rust GUIs essentially tells me to "pick three", which is unacceptable to me. A WebAssembly based application is the best we\'ll get for now, and I am fine with that.'}),"\n",(0,s.jsxs)(t.p,{children:["Compiling to WebAssembly isn't all that easy though: The ",(0,s.jsx)(t.code,{children:"wasm32-unknown-unknown"})," target intentionally makes no assumptions about the environment it is deployed in, and therefore does not provide things like a ",(0,s.jsx)(t.code,{children:"net"})," or ",(0,s.jsx)(t.code,{children:"filesystem"})," implementation (amongst other things). Luckily, adding support for this compilation target only took me a full 40h work week [:)], and we are now the first Rust Discord-API library (that I know of) to support this target."]}),"\n",(0,s.jsx)(t.p,{children:"You might not have yet heard much about WebAssembly: In the past, web developers could only really use three languages - HTML, CSS, and JavaScript - to write code that browsers could understand directly. With WebAssembly, developers can write code in many other languages, then use WASM to convert it into a form the browser can run."}),"\n",(0,s.jsx)(t.p,{children:"This is particularly helpful for programs that require a lot of computing power, like video games or design software. Before, running such programs in a browser would be slow or impossible. WebAssembly can make these run smoothly, right in your web browser."}),"\n",(0,s.jsx)(t.p,{children:"Overall, WebAssembly is expanding the kinds of applications that can be run on the web, making the web a more flexible and powerful place to work and play. Compiling Chorus for WASM allows us to leverage this fairly new technology and bring all of Rusts benefits into a web context."}),"\n",(0,s.jsx)(t.p,{children:"The next blog post will likely be about progress with the web-based client. See ya until then! :)"})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(6540);const s={},r=o.createContext(s);function i(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);