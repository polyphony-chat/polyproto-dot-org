"use strict";(self.webpackChunkpolyproto_docs=self.webpackChunkpolyproto_docs||[]).push([[8564],{309:e=>{e.exports=JSON.parse('{"permalink":"/blog/2023/09/02/client-getting-started","source":"@site/blog/2023-09-02-client-getting-started.md","title":"Getting started with the Polyphony Client","description":"{/ truncate /}","date":"2023-09-02T00:00:00.000Z","tags":[],"readingTime":1.58,"hasTruncateMarker":true,"authors":[{"name":"bitfl0wer","description":"Lead silly individual","avatar":"https://avatars.githubusercontent.com/u/39242991?v=4","key":"bitfl0wer","page":null}],"frontMatter":{"draft":false,"date":"2023-09-02T00:00:00.000Z","categories":["polyphony","updates"],"authors":["bitfl0wer"]},"unlisted":false,"prevItem":{"title":"Porting chorus to WebAssembly + Client Update","permalink":"/blog/2023/11/23/webassembly-chorus"},"nextItem":{"title":"chorus Alpha 0.1.0","permalink":"/blog/2023/08/29/chorus-alpha"}}')},3711:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>h});var n=a(309),o=a(4848),s=a(8453);const i={draft:!1,date:new Date("2023-09-02T00:00:00.000Z"),categories:["polyphony","updates"],authors:["bitfl0wer"]},r="Getting started with the Polyphony Client",l={authorsImageUrls:[void 0]},h=[];function c(e){const t={em:"em",p:"p",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:["\n",(0,o.jsxs)(t.p,{children:["Us labeling Chorus to be in a public-alpha state was really great news for me, for a lot of reasons! It marked a point in Polyphonys history where, after all these months of work, we agreed upon the fact that what we ",(0,o.jsx)(t.em,{children:"have"})," is good enough to be shown to the public, and that's always a nice thing when investing so much of your free-time into a project.\nThe other main reason why this is such a great thing is, because this alpha state (at least to me) means, that the public API is kind-of stable, or at least stable enough so that I, the project lead, can rely upon the fact that all the public methods will not, in fact, be replaced in 4 days."]}),"\n",(0,o.jsxs)(t.p,{children:["This means, that I can finally start working on the Client! And I have done that! For the past 2? 3? Days, I've been tinkering around with Iced-rs (a really, really great UI framework for Rust, written in Rust) and the client repository to create the 'skeleton' of the application. While this is definitely not trivial, especially since I have ",(0,o.jsx)(t.em,{children:"no"})," prior experience in desktop application development, it's also not too hard either."]}),"\n",(0,o.jsx)(t.p,{children:'While Iced is not mature yet, and "how-to" guides, as well as the promised Iced-book, are still largely missing, the maintainers have done a great job with providing a LOT of code examples and solid rustdocs. It\'s a fun library/framework to work with, and the Elm-inspired approach of dividing up State, Messages, View- and Update-Logic feels really intuitive and seems to make sure that your Application will never end up in an unexpected state.'}),"\n",(0,o.jsx)(t.p,{children:"That's all I have for today. Thanks for reading this! Here's a video of multi-user login already working ^^"}),"\n",(0,o.jsx)("video",{controls:!0,width:"auto",children:(0,o.jsx)("source",{src:"https://cloud.bitfl0wer.de/index.php/s/Gd556SnwAQYejYw/download/screenrec.mp4"})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>r});var n=a(6540);const o={},s=n.createContext(o);function i(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);