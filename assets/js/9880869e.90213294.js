"use strict";(self.webpackChunkpolyproto_docs=self.webpackChunkpolyproto_docs||[]).push([[1792],{3566:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>n,toc:()=>h});var n=o(8556),i=o(4848),s=o(8453);const a={date:new Date("2024-06-01T00:00:00.000Z"),categories:["polyproto"],authors:["bitfl0wer"],title:"polyproto extensions"},r="polyproto extensions.",l={authorsImageUrls:[void 0]},h=[{value:"To federate is to be familiar",id:"to-federate-is-to-be-familiar",level:2},{value:"We need a common foundation",id:"we-need-a-common-foundation",level:2},{value:"...the <em>polyproto</em> foundation. Get it? <em>sigh</em>",id:"the-polyproto-foundation-get-it-sigh",level:2},{value:"Is this a bottleneck for me as a developer",id:"is-this-a-bottleneck-for-me-as-a-developer",level:2},{value:"Closing words",id:"closing-words",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",div:"div",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"polyproto is a new federation protocol. Its main focus is enabling seamless participation of one\nactor on many different servers. The core specification lacks routes for sending any sort of user\ngenerated data anywhere, though. What is up with that?"}),"\n","\n",(0,i.jsx)(t.h2,{id:"to-federate-is-to-be-familiar",children:"To federate is to be familiar"}),"\n",(0,i.jsxs)(t.p,{children:["If any application wants to participate in the network of polyproto services, it has to speak the\nsame language as those other services. When wanting to send a message to a server that you are\nauthenticated on, your client needs to know exactly what that HTTP request has to look like. This\nis nothing new. One take on a solution for this problem stems from the people working on the\nATProtocol, who created ",(0,i.jsx)(t.a,{href:"https://atproto.com/guides/lexicon",children:"Lexicon"}),". From the atproto website:"]}),"\n",(0,i.jsx)(t.p,{children:':::quote "Lexicon TL;DR"'}),"\n",(0,i.jsxs)(t.p,{children:['Lexicon is a global schema system. It uses reverse-DNS names like "',(0,i.jsx)(t.code,{children:"com.example.ping()"}),"\". The\ndefinitions are JSON documents, similar to JSON-Schema. It's currently used for HTTP endpoints,\nevent streams, and repo records"]}),"\n",(0,i.jsx)(t.p,{children:"The core of polyproto is supposed to be infinitely adaptable, to be flexible enough to be used for\njust about anything, which is why I do not want to force a fixed set of routes onto every single\npolyproto implementation."}),"\n",(0,i.jsxs)(t.p,{children:['Lexicon sounds interesting and really versatile! However, as mature as the idea itself might be, it\nis pretty complex and does not yet seem to have good community support in the form of\nlibraries/crates to aid in working with this new schema system. I also do not want to force polyproto\nintegrations to use a (potentially very complex) Lexicon parser and dynamic routing system\nthingymajig - although having "no rules" means, that if you ',(0,i.jsx)(t.em,{children:"want"})," to build a polyproto service\nwhich uses Lexicon, you absolutely can."]}),"\n",(0,i.jsx)(t.h2,{id:"we-need-a-common-foundation",children:"We need a common foundation"}),"\n",(0,i.jsx)(t.p,{children:"I am a big proponent of defining a set of (mutually independent) protocol extensions, which include\nadditionally needed behavior and concrete HTTP routes for building a specific application. This has the following benefits:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"If you'd like to build a polyproto chat client, and there's a polyproto-chat extension, you\nsimply need to add the additional things required by that extension. No need for complex parsing! Code only what you need and do not care about the rest."}),"\n",(0,i.jsx)(t.li,{children:"Mutual independence means being able to combine extensions however you'd like. You could, for\nexample, create a chat app with integrated microblogging functionality."}),"\n",(0,i.jsx)(t.li,{children:"Developers are free to come up with whatever they want. How about ActivityPub x polyproto? Since\npolyproto doesn't define a message format, this is absolutely possible!"}),"\n",(0,i.jsx)(t.li,{children:'Simplicity! polyproto and its "official" extensions will always just have plain old REST APIs,\nfor which tooling is readily available. Why bother with something fancy and dynamic, when this\ndoes the trick?'}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"On the other hand, everyone now has to agree on one extension to use for a specific application. You\ncannot participate on servers, which have use an extension which is completely different from the one\nthat your client implements, as an example."}),"\n",(0,i.jsxs)(t.h2,{id:"the-polyproto-foundation-get-it-sigh",children:["...the ",(0,i.jsx)(t.em,{children:"polyproto"})," foundation. Get it? ",(0,i.jsx)(t.em,{children:"sigh"})]}),"\n",(0,i.jsx)(t.p,{children:'To develop, provide and maintain polyproto and some major "official" extensions (such as polyproto-chat),\ncreating a non-profit foundation is likely a good idea for a future where polyproto is actually being\nused in the real world.'}),"\n",(0,i.jsxs)(t.p,{children:["This could sort of be seen like the XMPP Standards Foundation which develops and maintains XMPP\nextensions. Unlike XMPPs extensions however, official polyproto extensions should always be ",(0,i.jsx)(t.em,{children:"major"}),"\nadditions in functionality. As an example: ",(0,i.jsx)(t.a,{href:"https://xmpp.org/extensions/xep-0084.html",children:"XEP-0084"})," is\nthe official XMPP extension for User Avatars. An entire 12 point document, which describes one simple\nfeature!"]}),"\n",(0,i.jsxs)(t.p,{children:["polyproto extensions should either always be a major technological addition, which can be taken\nadvantage of by other extensions (examples for this would be WebSocket Gateways and\nMessaging Layer Security), or a document describing a ",(0,i.jsx)(t.strong,{children:"set"})," of routes, which define a particular\napplication use case (A Discord-like, a Reddit-like, a Twitter-like, and so on). Having official\nextensions adhere to these rules ensures that polyproto will not become a cluttered mess of\nextensions and that it and its extensions are easy to understand and implement, due to less\ndocumentation having to be read and written."]}),"\n",(0,i.jsx)(t.h2,{id:"is-this-a-bottleneck-for-me-as-a-developer",children:"Is this a bottleneck for me as a developer"}),"\n",(0,i.jsx)(t.p,{children:"If you are a developer, you might ask yourself:"}),"\n",(0,i.jsxs)(t.div,{children:[(0,i.jsx)(t.p,{children:"Implementing common chat behaviour sounds cool in terms of intercompatibility, but doesn't this\nlimit what I can do with my application? I have planned for a cool feature X to exist in my chat\nservice, but that doesn't exist in the protocol extension!"}),(0,i.jsx)(t.p,{children:'Extensions should be a usable minimum of common behavior that all implementations targeting the\nsame "class" of application must share. Implementations can absolutely offer all the additional\nspecial/unique features they\'d like, though. polyproto clients implementing the same extensions\ncan be treated as clients with a reduced feature set in this case. What is crucial, however, is\nthat the additional features do not prohibit "reduced feature set clients" from using the behavior\ndescribed in the extension, if any sort of federation or interoperability is wanted.'}),(0,i.jsxs)(t.admonition,{title:"Example: What works",type:"tip",children:[(0,i.jsx)(t.p,{children:"In your implementation of a chat service, users can send each other messages with special\neffects, such as fireworks, confetti and similar. A different implementation of polyproto-chat\nis unlikely to see these special effects on their end. However, they can still see the messages'\ntext contents, send replies to the message, and do all sorts of other things as described in\nthis hypothetical polyproto-chat extension."}),(0,i.jsxs)(t.admonition,{title:"Example: What doesn't work",type:"tip",children:[(0,i.jsx)(t.p,{children:"In your implementation of a chat service, users can send each other messages with special effects,\nsuch as fireworks, confetti and similar. Your implementation requires every client to send\ninformation about the special effect they'd like to send with a message - otherwise sending the\nmessage fails. If this is the case and you haven't implemented a sort of \"adapter\" for other\npolyproto-chat clients, these clients will not be able to send any messages to servers running\nyour chat software. This conflicts with the behaviour required by the polyproto-chat extension\nand is therefore unacceptable."}),(0,i.jsx)(t.p,{children:'Also keep in mind that through clever engineering, it might be possible to write adapters for\nbehavior, which should be required in your implementation and conflicts with the base extension.\nPicking up the "What doesn\'t work" example again, the implementer could simply "translate" message\nsending requests made to the polyproto-chat endpoints and add the required "special effects"\ninformation, stating that messages sent through polyproto-chat endpoints have no special effects\nadded to them.'}),(0,i.jsx)(t.h2,{id:"closing-words",children:"Closing words"}),(0,i.jsx)(t.p,{children:"I am of the opinion that, while this way of having extensions might not be the most technologically\nadvanced solution, it certainly offers many possibilities while being easy to understand and\nimplement."}),(0,i.jsxs)(t.p,{children:["These are my current plans, ideas and thoughts for making a v1 of polyproto extensible. If you have\nany thoughts on this matter, please do let me know! You can contact me via\n",(0,i.jsx)(t.a,{href:"mailto:flori@polyphony.chat",children:"email"})," or by writing a message on our ",(0,i.jsx)(t.a,{href:"https://discord.com/invite/m3FpcapGDD",children:"Discord"}),"."]}),(0,i.jsx)(t.p,{children:"Thank you for reading! :>"}),(0,i.jsx)(t.h1,{id:"happy-pride-month-\ufe0f\ufe0f\ufe0f",children:"Happy pride month! \ud83c\udff3\ufe0f\u200d\ud83c\udf08\ud83c\udff3\ufe0f\u200d\u26a7\ufe0f\ud83d\udc9b\ud83e\udd0d\ud83d\udc9c\ud83d\udda4"})]})]})]})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>a,x:()=>r});var n=o(6540);const i={},s=n.createContext(i);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(s.Provider,{value:t},e.children)}},8556:e=>{e.exports=JSON.parse('{"permalink":"/blog/2024/06/01/extensions","source":"@site/blog/2024-06-01-extensions.md","title":"polyproto extensions","description":"polyproto is a new federation protocol. Its main focus is enabling seamless participation of one","date":"2024-06-01T00:00:00.000Z","tags":[],"readingTime":5.9,"hasTruncateMarker":true,"authors":[{"name":"bitfl0wer","description":"Lead silly individual","avatar":"https://avatars.githubusercontent.com/u/39242991?v=4","key":"bitfl0wer","page":null}],"frontMatter":{"date":"2024-06-01T00:00:00.000Z","categories":["polyproto"],"authors":["bitfl0wer"],"title":"polyproto extensions"},"unlisted":false,"prevItem":{"title":"NLnet grant application","permalink":"/blog/2024/10/14/nlnet-grant-application"},"nextItem":{"title":"Work on polyproto and a \\"vacation\\" \u26f1\ufe0f","permalink":"/blog/2024/03/06/updates-and-vacation"}}')}}]);