"use strict";(self.webpackChunkpolyproto_dot_org=self.webpackChunkpolyproto_dot_org||[]).push([[3054],{3353:e=>{e.exports=JSON.parse('{"permalink":"/blog/2023/11/23/webassembly-chorus","source":"@site/blog/2023-11-23-webassembly-chorus.md","title":"Porting chorus to WebAssembly + Client Update","description":"What the current state of GUI libraries in Rust means for Polyphony and chorus, and why we are","date":"2023-11-23T00:00:00.000Z","tags":[],"readingTime":1.83,"hasTruncateMarker":false,"authors":[{"name":"bitfl0wer","description":"Lead silly individual","avatar":"https://avatars.githubusercontent.com/u/39242991?v=4","key":"bitfl0wer","page":null}],"frontMatter":{"draft":false,"date":"2023-11-23T00:00:00.000Z","categories":["chorus","polyphony","updates"],"authors":["bitfl0wer"]},"unlisted":false,"prevItem":{"title":"Account migration in polyproto","permalink":"/blog/2024/02/07/account-migration"},"nextItem":{"title":"Getting started with the Polyphony Client","permalink":"/blog/2023/09/02/client-getting-started"}}')},6311:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var o=n(3353),s=n(4848),r=n(8453);const i={draft:!1,date:new Date("2023-11-23T00:00:00.000Z"),categories:["chorus","polyphony","updates"],authors:["bitfl0wer"]},a="Porting chorus to WebAssembly + Client Update",l={authorsImageUrls:[void 0]},h=[];function c(e){const t={code:"code",em:"em",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"What the current state of GUI libraries in Rust means for Polyphony and chorus, and why we are\nporting chorus to WebAssembly."}),"\n",(0,s.jsx)(t.p,{children:"{/_ truncate _/}"}),"\n",(0,s.jsx)(t.p,{children:"Hi all!"}),"\n",(0,s.jsxs)(t.p,{children:["To make this part of the post short: The web-based client will be worked on ",(0,s.jsx)(t.em,{children:"before"})," the native one,\nif there even ever will be one. The reason is that no currently available native Rust GUI library\nmeets the standards I'd like to see when using it to build an application I am putting my name\nbehind. I'd like to have"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"accessibility"}),"\n",(0,s.jsx)(t.li,{children:"great styling"}),"\n",(0,s.jsx)(t.li,{children:"cross compilation"}),"\n",(0,s.jsx)(t.li,{children:"memory safety"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'and the current state of Rust GUIs essentially tells me to "pick three", which is unacceptable to\nme. A WebAssembly based application is the best we\'ll get for now, and I am fine with that.'}),"\n",(0,s.jsxs)(t.p,{children:["Compiling to WebAssembly isn't all that easy though: The ",(0,s.jsx)(t.code,{children:"wasm32-unknown-unknown"})," target\nintentionally makes no assumptions about the environment it is deployed in, and therefore does not\nprovide things like a ",(0,s.jsx)(t.code,{children:"net"})," or ",(0,s.jsx)(t.code,{children:"filesystem"})," implementation (amongst other things). Luckily, adding\nsupport for this compilation target only took me a full 40h work week [:)], and we are now the first\nRust Discord-API library (that I know of) to support this target."]}),"\n",(0,s.jsx)(t.p,{children:"You might not have yet heard much about WebAssembly: In the past, web developers could only really\nuse three languages - HTML, CSS, and JavaScript - to write code that browsers could understand\ndirectly. With WebAssembly, developers can write code in many other languages, then use WASM to\nconvert it into a form the browser can run."}),"\n",(0,s.jsx)(t.p,{children:"This is particularly helpful for programs that require a lot of computing power, like video games or\ndesign software. Before, running such programs in a browser would be slow or impossible. WebAssembly\ncan make these run smoothly, right in your web browser."}),"\n",(0,s.jsx)(t.p,{children:"Overall, WebAssembly is expanding the kinds of applications that can be run on the web, making the\nweb a more flexible and powerful place to work and play. Compiling Chorus for WASM allows us to\nleverage this fairly new technology and bring all of Rusts benefits into a web context."}),"\n",(0,s.jsx)(t.p,{children:"The next blog post will likely be about progress with the web-based client. See ya until then! :)"})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(6540);const s={},r=o.createContext(s);function i(e){const t=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);